## تحريك (حركة حيوية)!

+ قم بإنشاء الدالة البرمجية الجديدة التالية في أسفل رسمك التخطيطي:

``` 
        void animateOneColour(uint32_t c, uint8_t wait) {
        for(uint16_t i=0; i<strip.numPixels(); i++) {
            strip.setPixelColor(i, c);
            strip.show();
        }
    }
Can you see that this function takes two parameters in the rou
```

يمكنك أن ترى أن هذه الدالة البرمجية تستغرق اثنين المعلمات في الأقواس المستديرة؟ في وقت لاحق ، ستقوم بتغيير كود الدالة البرمجية بحيث تستخدم كود الثاني.

+ حذف الكود في `حلقة التكرار` الداله وإضافة استدعاء إلى الداله الجديدة:

```
    void loop() {
        animateOneColour(strip.Color(0, 0, 255), 100);
    }
```

لاحظ كيف تمرر` animateOneColour
 ` الدالة البرمجية معلمتين في الأقواس؟ على الرغم من أن الداله لا تستخدم الداله الثانية حتى الآن ، ولكن لن يتم تجميع الكود إذا لم تقم بتمرير القيم لجميع المعلمات عند استدعاء الداله.

+ تحقق وتحميل الكود. ماذا تلاحظ؟

هذه المرة تحتاج فقط إلى كتابة  سطر واحد من التعليمات البرمجية التي تستدعي `strip.setPixelColor`، و تشغيل جميع وحدات البكسل.

+ داخل وظيفتك(الداله) الجديدة ، هل يمكنك أن ترى أن هناك زوجًا آخر من أقواس متعرجة مع الكود بينهما؟ ينتمي هذا الزوج إلى شيء يسمى للحلقة التكراريه \ (لكن ليس حلقة تكراريه الدالة البرمجية!\). وهو يبدو بهذا الشكل:

``` 
    for(uint16_t i=0; i<strip.numPixels(); i++) {

    }
```

--- collapse ---
---
title: كيف يعمل الكود البرمجي؟
---

يتحقق الكود(التعليمات البرمجية) أعلاه من عدد NeoPixels في سلسلتك ثم يقوم بتشغيل الكود داخل الأقواس المتعرجة مرات عديدة.

إليك الجزء الذكي:  قيمة `i` يبدأ بـ `0` والتغييرات بواسطة `1` في كل مرة ، لذلك في كل مرة يكون فيها الخط `strip.setPixelColor (i, c);` يعمل ، يتم تعيين لون التالي بكسل!

--- /collapse ---

+ حان الوقت للقيام بشيء ما مع تلك المعلمة الثانية! في `animateOneColour الخاص بك` دالة برمجية ، أضف السطر التالي أسفل الخط` strip.show ();`:

```
    delay(wait);
```

تأكد من أن السطر الجديد هو أعلاه أول `}` ، بحيث يكون داخل حلقة for التكراريه. يجب أن تبدو التعليمات البرمجية والدوال بالشكل التالي:

``` 
    void animateOneColour(uint32_t c, uint8_t wait) {
        for(uint16_t i=0; i<strip.numPixels(); i++) {
            strip.setPixelColor(i, c);
            strip.show();
            delay(wait);
        }
    }
```

بدلاً من استخدام رقم معين `للتأخير` ، أنت تستخدم المعلمة الثانية من وظيفتك(الداله). هذا يعني أنه يمكنك اختيار قيمة مختلفة `للتأخير` في كل مرة تستدعي الوظيفة.

+ أضف استدعاء أخر إلى دالتك البرمجية داخل `حلقة تكراريه` لإيقاف تشغيل NeoPixels وكذلك تشغيله:

    ```
        void loop() {
            animateOneColour(strip.Color(0, 0, 255), 100);
            animateOneColour(strip.Color(0, 0, 0), 100);
        }
    ```

+ تحقق من الكود الخاص بك مرة أخرى وقم بتحميل الرسم إلى Flora. الآن لديك تسلسل متحرك رائع!

بالطبع ، ليس عليك إيقاف تشغيل NeoPixels. ماذا عن جعلها كلها تضيء في مجموعة من الألوان واحدة تلو الأخرى؟

```
    void loop() {
        animateOneColour(strip.Color(255, 127, 0), 100);
        animateOneColour(strip.Color(255, 0, 255), 100);
        animateOneColour(strip.Color(0, 255, 255), 100);
    }
```

+ أضف العديد من الألوان كما تريد. حاول تمرير قيم مختلفة غير `100` للمعلمة الثانية أيضًا ، وشاهد الرسوم المتحركة تسرع أو تبطئ!
